;===============================================
; Rosetta.art
;
; RosettaCode helper
; for Arturo
;
; MIT License
; (c) 2025 Yanis Zafirópulos
;===============================================

import'mwiki!

;===========================================
; Type definitions
;===========================================

define :rcSolution [
    init: method [language :string, content :string][
        \language: language
        \content: content
        
        \code: []
        codeParts: split.by:"<syntaxhighlight" \content
        if 1 < size codeParts [
            loop slice codeParts 1 (size codeParts)-1 'part [
                ; Find closing tag
                if contains? part "</syntaxhighlight>" [
                    innerParts: split.by:">" part
                    if 1 < size innerParts [
                        codePart: join.with:">" slice innerParts 1 (size innerParts)-1
                        codePart: first split.by:"</syntaxhighlight>" codePart
                        \code: \code ++ strip codePart
                    ]
                ]
            ]
        ]
        
        \output: null
        if contains? \content "{{out}}" [
            outParts: split.by:"{{out}}" \content
            if 1 < size outParts [
                afterOut: last outParts
                if contains? afterOut "<pre>" [
                    preParts: split.by:"<pre>" afterOut
                    if 1 < size preParts [
                        outputPart: first split.by:"</pre>" last preParts
                        \output: strip outputPart
                    ]
                ]
            ]
        ]
    ]
    
    string: method [][
        ~"Solution: |\language| (|size \content| chars)"
    ]
]

define :rcTask [
    init: method [wiki :MW, title :string][
        \wiki: wiki
        \title: title

        \_content: attr 'content
        \_draft?: null
        \_description: null
        \_categories: null
        \_solutions: null
    ]
    
    parseContent: method [][
        if null? \_content -> return false
        
        lines: split.lines \_content
        
        ; Extract categories
        \_categories: []
        \_draft?: false
        
        loop lines 'line [
            if contains? line "{{task|" [
                parts: split.by:"|" line
                if 1 < size parts [
                    catPart: last parts
                    catPart: replace catPart "}}" ""
                    \_categories: \_categories ++ strip catPart
                ]
            ]
            if contains? line "{{draft task|" [
                \_draft?: true
                parts: split.by:"|" line
                if 1 < size parts [
                    catPart: last parts
                    catPart: replace catPart "}}" ""
                    \_categories: \_categories ++ strip catPart
                ]
            ]
        ]
        
        ; Extract description
        descLines: []
        loop lines 'line [
            if and? [prefix? line "=="] [suffix? line "=="] -> break
            descLines: descLines ++ line
        ]
        \_description: strip join.with:"\n" descLines
        
        ; Extract solutions
        \_solutions: []
        currentLang: null
        currentContent: []
        
        loop lines 'line [
            switch and? [prefix? line "=={{header|"] [contains? line "}}=="] [
                ; Save previous solution
                if currentLang [
                    sol: to :rcSolution @[currentLang join.with:"\n" currentContent]!
                    \_solutions: \_solutions ++ sol
                ]
                
                ; Start new solution
                parts: split.by:"|" line
                if 1 < size parts [
                    langPart: first slice parts 1 (size parts)-1
                    langPart: replace langPart "}}==" ""
                    currentLang: strip langPart
                    currentContent: []
                ]
            ][
                if currentLang ->
                    currentContent: currentContent ++ line
            ]
        ]
        
        ; Extract last solution
        if currentLang [
            sol: to :rcSolution @[currentLang join.with:"\n" currentContent]!
            \_solutions: \_solutions ++ sol
        ]
        
        return true
    ]
    
    content: method [][
        ;; description: « get task content, loading from wiki if needed
        ;; returns: :string :null
        
        if \_content -> return \_content
        
        page: \wiki\page \title
        if null? page -> return ø
        
        \_content: page\content
        \parseContent
        
        return \_content
    ]
    
    draft?: method [][
        ;; description: « check if task is a draft
        ;; returns: :logical :null
        
        unless null? \_draft? -> return \_draft?
        
        ; Force content load which will parse and set \_draft?
        discard \content

        return \_draft?
    ]
    
    description: method [][
        ;; description: « get task description
        ;; returns: :string :null
        
        if \_description -> return \_description
        discard \content        ; see above^

        return \_description
    ]
    
    categories: method [][
        ;; description: « get task categories
        ;; returns: :block :null
        
        if \_categories -> return \_categories
        discard \content        ; see above^

        return \_categories
    ]
    
    solutions: method [][
        ;; description: « get all language solutions
        ;; returns: :block :null
        
        if \_solutions -> return \_solutions
        discard \content        ; see above^

        return \_solutions
    ]
    
    solution: method [lang :string][
        ;; description: « get solution for specific language
        ;; returns: :rcSolution :null
        
        sols: \solutions
        if null? sols -> return ø
        
        return first select.first sols 'sol -> sol\language = lang
    ]
    
    ; addSolution: method [solution :rcSolution, summary :string :null][
    ;     ;; description: « add or update solution for this task
    ;     ;; returns: :logical
        
    ;     unless \wiki\loggedIn -> return false
        
    ;     cnt: \content
    ;     if null? cnt -> return false
        
    ;     sectionHeader: ~"=={{header||\solution\language|}}=="
        
    ;     ; Check if language section exists
    ;     newContent: (contains? cnt sectionHeader)? [
    ;         ; Replace existing solution
    ;         parts: split.by:sectionHeader cnt
    ;         before: first parts
    ;         after: split.by:"\n==" last parts
            
    ;         result: before ++ sectionHeader ++ "\n" ++ solution\content
    ;         (1 < size after)?
    ;             -> result ++ "\n==" ++ join.with:"\n==" slice after 1 (size after)-1
    ;             -> result
    ;     ][
    ;         ; Add new section at end
    ;         cnt ++ "\n\n" ++ sectionHeader ++ "\n" ++ solution\content
    ;     ]
        
    ;     sum: summary ?? "Added " ++ solution\language ++ " solution"
        
    ;     success: \wiki\editPage \title newContent sum
        
    ;     if success [
    ;         \_content: newContent
    ;         \parseContent
    ;     ]
        
    ;     return success
    ; ]
    
    string: method [][
        ~"Task: |\title|"
    ]
]

;===========================================
; Main Implementation
;===========================================

define :Rosetta [

    ;------------------------------
    ; Constructor
    ;------------------------------

    init: method [][
        \wiki: to :MW ["https://rosettacode.org/w/api.php"]
        \loggedIn: false
    ]
    
    ;----------------------------------
    ; Methods
    ;----------------------------------
    
    login: method [username :string, password :string][
        ;; description: « authenticate with RosettaCode
        ;; returns: :logical

        \loggedIn: \wiki\login username password
        return \loggedIn
    ]
    
    task: method [title :string][
        ;; description: « retrieve task content
        ;; returns: :rcTask :null

        page: \wiki\page title
        if null? page -> return ø
        
        return to :rcTask.content: page\content @[\wiki title]
    ]
    
    unimplemented: method [lang :string][
        ;; description: « find all tasks without implementation for given language
        ;; returns: :block
        
        allTasks: \wiki\category "Programming_Tasks"
        langTasks: \wiki\category lang
        
        if null? allTasks -> return []
        if null? langTasks -> return []

        cleanTitles: filter difference allTasks\members langTasks\members =>
            [prefix? & "Category:"]
        
        return map cleanTitles 'title ->
            to :rcTask @[\wiki title]
    ]
    
    implemented: method [lang :string][
        ;; description: « get all tasks with implementations for given language
        ;; returns: :block

        langTasks: \wiki\category lang
        if null? langTasks -> return []
        
        cleanTitles: filter langTasks\members =>
            [prefix? & "Category:"]

        return map cleanTitles 'title ->
            to :rcTask @[\wiki title]
    ]
    
    drafts: method [][
        ;; description: « get draft programming tasks
        ;; returns: :block

        lmt: 1000
        draftCat: \wiki\category.limit:lmt "Draft_Programming_Tasks"
        
        if null? draftCat -> return []
        
        cleanTitles: filter draftCat\members =>
            [prefix? & "Category:"]
        
        return map cleanTitles 'title ->
            to :rcTask @[\wiki title]
    ]

    ;------------------------------
    ; Magic
    ;------------------------------
    
    string: method [][
        status: \loggedIn ? -> "logged in" -> "not logged in"
        ~"RosettaCode (|status|)"
    ]
]